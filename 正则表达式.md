# 正则表达式
> Regular Expression 使用单个字符串匹配符合一系列规则的字符串
[正则图形化测试](http://regexper.com).
### 实例化RegExp对象
* 字面量
/xxx/
* 构造函数
new RegExp()
* 修饰符
g：全局匹配
i：忽略大小写
m：多行搜索

### 字符类型
* 原义字符
* 元字符
\t
\v
\n
\0
\f
\cX
* 有特殊含义的非字母字符
\* + ? $ ^ | \\ () {} []
\*: 0
[]:归类 one of 
^：字符类取反


### 范围类
* [a-z]:a~z任意字符
[a-zA-Z]:范围类可以连写

### 预定义类
字符|等价类|含义
-|-|-
.|[^\r\n]|除了回车符和换行符之外的所有字符
\d|[0-9]|数字字符
\D|[^0-9]|非数字字符
\s|[\t\n\x0B\f\r]|空白符
\S|[^\t\n\x0B\f\r]|非空白符
\w|[a-zA-Z_0-9]|单词字符(字母、数字和下划线)
\W|[^a-zA-Z_0-9]|非单词字符

### 边界
字符|含义
-|-
^|以xxx开始
$|以xxx结束
\b|单词边界
\B|非单词边界

### 量词
字符|含义
-|-
?|出现0或一次
+|出现一次或多次
\*|出现0次或多次
\{n}|出现n次
\{n,m}|出现n到m次
\{n,}|至少出现n次

### 贪婪模式
>尽可能多的匹配

### 非贪婪模式
>尽可能少的匹配(在量词后面加?)

### 分组
>使用()可以达到分组的功能，使量词作用于分组

### 或
>使用|可以达到或的效果

### 反向引用
> 使用$+数字捕获分组

### 忽略分组
> (?:byron).(ok) $1代表ok

### 前瞻
名称|正则|含义
-|-|-
正向前瞻|exp(?=assert)|后面是断言的匹配
负向前瞻|exp(?!assert)|后面不是断言的匹配
正向后顾|exp(?<=assert)|JS不支持
负向后顾|exp(?<assert)|JS不支持

### JS正则表达式方法
* RegExp.prototype.test():用于测试字符串参数中是否存在匹配正则表达模式的字符串
如果存在返回true，否则返回false
* RegExp.prototype.exec():使用正则表达式模式对字符串进行搜索，并将更新全局RegExp对象的属性以反映匹配结果
如果没有匹配文本则返回null，否则返回一个结果数组

### 字符串对象的方法
* String.prototype.search(reg):用于检索字符串中的子字符串，或检索与正则表达式相匹配的子字符串,g不起作用
* String.prototype.match(reg):检索一个字符串找到一个或多个与reg匹配的文本，reg是否具有g对结果影响很大
